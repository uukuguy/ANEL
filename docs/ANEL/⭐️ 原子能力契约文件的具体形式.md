# ⭐️ 原子能力契约文件的具体形式

[**Phase 0.2 —— 定义“原子能力”**。](https://www.notion.so/Phase-0-2-306fc249f8b0809bad2ef9c29ef5f0b5?pvs=21) 

你问这三个契约是什么形式？它们是**测试固件 (Test Fixtures)**。在工程目录中，它们是实实在在的 `.json` 或 `.yaml` 文件。

**推荐的工程目录结构：**

Plaintext

`anel-project/
├── docs/
│   └── spec/
│       └── ANID_v1.0_RFC.md       <-- 上面的文档存这里
│
└── tests/
    └── fixtures/                  <-- 这里存放“契约”文件
        └── svc-check/             <-- 针对 svc-check 工具的契约
            ├── introspection.yaml <-- [契约1] 自省定义
            ├── success.ndjson     <-- [契约2] 成功时的标准输出
            └── error_400.json     <-- [契约3] 失败时的标准错误`

```json
tests/fixtures/svc-check/
├── introspection.yaml        # [契约1] 自省定义（静态，通常只有一个）
├── success_http_200.ndjson   # [契约2] 成功：正常返回
├── success_batch.ndjson      # [契约2] 成功：批量检测返回（可选）
│
├── error_case_invalid_arg.json    # [契约3-A] 失败：参数错误
├── error_case_timeout.json        # [契约3-B] 失败：网络超时
└── error_case_auth_fail.json      # [契约3-C] 失败：鉴权失败
```

### 1. 自省契约文件 (`introspection.yaml`)

这是**定义文件**。Rust 代码中的 `CommandMetadata` 结构体序列化后，必须和这个文件一致。

YAML

`# tests/fixtures/svc-check/introspection.yaml
name: "svc-check"
description: "Checks the health of a target service."
args:
  - name: "--target"
    required: true
    type: "string"
# ... (其余内容同之前讨论)`

### 2. 成功契约文件 (`success.ndjson`)

这是**预期输出文件**。你的测试代码会运行 `svc-check`，捕获 stdout，然后和这个文件做 `diff`。

JSON

`// tests/fixtures/svc-check/success.ndjson
{"timestamp": "2026-02-13T10:00:00Z", "status": "checking"}
{"timestamp": "2026-02-13T10:00:01Z", "status": "up", "code": 200}`

### 3. 失败契约文件 (`error_400.json`)

应当是“每个典型错误场景一个文件“。

因为**失败契约（Failure Contract）不仅仅是验证“它报错了”，而是验证“它是否针对不同的错误，给出了正确的、差异化的自愈建议（Recovery Hints）”**。

对于智能体（Agent）来说，参数填错了（需要改参数）和网络超时了（需要重试），是完全不同的两种“修复策略”。如果混在一个文件里，测试逻辑会变得非常混乱。

这是**错误处理标准**。测试代码会故意输入错误参数，捕获 stderr，确保生成的 JSON 包含 `recovery_hints`。

JSON

`// tests/fixtures/svc-check/error_400.json
{
  "error_code": "E_INVALID_ARG",
  "severity": "fatal",
  "recovery_hints": ["Ensure URL starts with http"]
}`

### 1. 推荐的文件组织结构

在你的工程目录中，`tests/fixtures/svc-check/` 应该长这样：

Plaintext

`tests/fixtures/svc-check/
├── introspection.yaml        # [契约1] 自省定义（静态，通常只有一个）
├── success_http_200.ndjson   # [契约2] 成功：正常返回
├── success_batch.ndjson      # [契约2] 成功：批量检测返回（可选）
│
├── error_case_invalid_arg.json    # [契约3-A] 失败：参数错误
├── error_case_timeout.json        # [契约3-B] 失败：网络超时
└── error_case_auth_fail.json      # [契约3-C] 失败：鉴权失败`

---

### 2. 为什么要拆分？（差异化对比）

请看下面两个错误文件的内容对比，你会发现它们对 Agent 的指导意义完全不同。

### 场景 A：参数错误 (`error_case_invalid_arg.json`)

- **触发条件**：Agent 执行了 `svc-check --target google` (忘了写 https)。
- **测试重点**：验证 `severity` 是否为 `fatal`，以及 Hint 是否包含格式修正建议。

JSON

`{
  "error_code": "E_INVALID_ARG",
  "message": "Invalid URL format provided",
  "severity": "fatal",  // <--- 关键点：这是致命错误，重试没用
  "context": { "input": "google" },
  "recovery_hints": [
    "URL must start with 'http://' or 'https://'" // <--- 关键点：指导改参
  ]
}`

### 场景 B：网络超时 (`error_case_timeout.json`)

- **触发条件**：Agent 执行了 `svc-check --target https://timeout.example.com`。
- **测试重点**：验证 `severity` 是否为 `retryable`，这决定了 Agent 是放弃还是重试。

JSON

`{
  "error_code": "E_CONNECT_TIMEOUT",
  "message": "Connection timed out after 5000ms",
  "severity": "retryable", // <--- 关键点：这是可重试的
  "context": { "timeout_setting": 5 },
  "recovery_hints": [
    "Wait for 5 seconds and retry",  // <--- 关键点：指导行为
    "Increase timeout using '--timeout 15'"
  ]
}`

---

### 3. 如何在 Rust 中使用这些文件？

在写测试代码时（比如使用 `cargo test`），你会编写一个测试函数，遍历这些文件。

**伪代码逻辑：**

Rust

`#[test]
fn test_error_contracts() {
    let test_cases = vec![
        // (模拟的输入参数, 期望匹配的契约文件)
        (vec!["--target", "google"], "error_case_invalid_arg.json"),
        (vec!["--target", "https://timeout.com"], "error_case_timeout.json"),
    ];

    for (args, expected_file) in test_cases {
        // 1. 运行你的工具
        let output = run_svc_check(args);

        // 2. 读取契约文件
        let expected_json = fs::read_to_string(format!("tests/fixtures/svc-check/{}", expected_file));

        // 3. 验证 stderr 是否完全匹配契约
        assert_json_eq!(output.stderr, expected_json);
    }
}`

### 总结

- **自省契约**：通常只有 **1 个** 文件（定义是静态的）。
- **成功契约**：通常有 **1-2 个** 文件（覆盖典型输出结构）。
- **失败契约**：通常有 **3-5 个** 文件（覆盖所有典型的错误分支：参数错、网络错、权限错、资源不存在等）。

**现在的行动**：请在 `tests/fixtures/svc-check/` 下至少创建 `error_invalid_arg.json` 和 `error_timeout.json` 这两个文件，以覆盖“不可重试”和“可重试”两种最典型的 ANID 错误路径。